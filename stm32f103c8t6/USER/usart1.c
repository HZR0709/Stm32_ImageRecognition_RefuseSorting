/***************************************
 * 文件名  ：usart1.c
 * 描述    ：配置USART1         
 * 实验平台：MINI STM32开发板 基于STM32F103C8T6
 * 硬件连接：------------------------
 *          | PA9  - USART1(Tx)      |
 *          | PA10 - USART1(Rx)      |
 *           ------------------------
 * 库版本  ：ST3.0.0  

**********************************************************************************/
#include "sys.h"
#include "usart1.h"
#include <stdarg.h>

// 接收缓冲,最大USART_REC_LEN个字节.
u8 USART_RX_BUF[USART_REC_LEN];
// 接收状态
// bit15，	接收完成标志   
// bit14，	接收到0x0d
// bit13~0，	接收到的有效字节数目
u16 USART_RX_STA = 0; // 接收状态标记

// UART1初始化
void uart1_init(u32 bound)
{
    // GPIO端口设置
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE); // 使能USART1，GPIOA时钟

    // USART1_TX   GPIOA.9
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; // PA.9
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 复用推挽输出
    GPIO_Init(GPIOA, &GPIO_InitStructure);         // 初始化GPIOA.9

    // USART1_RX	  GPIOA.10初始化
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;                   // PA10
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;        // 浮空输入
    GPIO_Init(GPIOA, &GPIO_InitStructure);                       // 初始化GPIOA.10

    // USART1 NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; // 抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;        // 子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;           // IRQ通道使能
    NVIC_Init(&NVIC_InitStructure);                           // 根据指定的参数初始化VIC寄存器

    // USART 初始化设置
    USART_InitStructure.USART_BaudRate = bound;                        // 串口波特率
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;         // 字长为8位数据格式
    USART_InitStructure.USART_StopBits = USART_StopBits_1;             // 一个停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;                // 无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; // 无硬件数据流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;    // 收发模式

    USART_Init(USART1, &USART_InitStructure); // 初始化串口1
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); // 开启串口接受中断
    USART_Cmd(USART1, ENABLE);                      // 使能串口1
}

// 串口1中断服务程序
void USART1_IRQHandler(void)
{
    u8 Res;

    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) // 接收中断(接收到的数据必须是0x0d 0x0a结尾)
    {
        Res = USART_ReceiveData(USART1);    // 读取接收到的数据

        if ((USART_RX_STA & 0x8000) == 0) // 接收未完成
        {
            if (USART_RX_STA & 0x4000) // 接收到了0x0d
            {
                if (Res != 0x0a)
                    USART_RX_STA = 0;   // 接收错误,重新开始
                else
                    USART_RX_STA |= 0x8000; // 接收完成了 
            }
            else // 还没收到0X0D
            {
                if (Res == 0x0d)
                    USART_RX_STA |= 0x4000;
                else
                {
                    USART_RX_BUF[USART_RX_STA & 0X3FFF] = Res;
                    USART_RX_STA++;
                    if (USART_RX_STA > (USART_REC_LEN - 1))
                        USART_RX_STA = 0; // 接收数据错误,重新开始接收	  
                }
            }
        }
    }
}

// 根据长度向串口3 发送数据
void usart1_SendStringByLen(unsigned char *data, u8 len)
{
    u16 i = 0;
    for (i = 0; i < len; i++)
    {
        USART_SendData(USART1, data[i]); // 向串口1发送数据
        while (USART_GetFlagStatus(USART1, USART_FLAG_TC) != SET); // 等待发送结束
    }
}

// 重定向c库函数printf到USART2
int fputc(int ch, FILE *f)
{
    // 将Printf内容发往串口
    USART_SendData(USART1, (unsigned char)ch);
    while (!(USART1->SR & USART_FLAG_TXE));

    return (ch);
}

// 发送一个字节数据
void UART1SendByte(unsigned char SendData)
{
    USART_SendData(USART1, SendData);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}

// 接收一个字节数据
unsigned char UART1GetByte(unsigned char *GetData)
{
    if (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET)
    {
        return 0; // 没有收到数据 
    }
    *GetData = USART_ReceiveData(USART1);
    return 1; // 收到数据
}

// 接收一个数据，马上返回接收到的这个数据
void UART1Test(void)
{
    unsigned char i = 0;

    while (1)
    {
        while (UART1GetByte(&i))
        {
            USART_SendData(USART1, i);
        }
    }
}

